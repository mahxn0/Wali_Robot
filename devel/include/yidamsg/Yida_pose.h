// Generated by gencpp from file yidamsg/Yida_pose.msg
// DO NOT EDIT!


#ifndef YIDAMSG_MESSAGE_YIDA_POSE_H
#define YIDAMSG_MESSAGE_YIDA_POSE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace yidamsg
{
template <class ContainerAllocator>
struct Yida_pose_
{
  typedef Yida_pose_<ContainerAllocator> Type;

  Yida_pose_()
    : id(0)
    , x(0.0)
    , y(0.0)
    , z(0.0)
    , anglex(0.0)
    , angley(0.0)
    , anglez(0.0)
    , prob(0.0)
    , x1(0.0)
    , y1(0.0)
    , x2(0.0)
    , y2(0.0)
    , x3(0.0)
    , y3(0.0)
    , x4(0.0)
    , y4(0.0)
    , road_line_status(0)
    , robot_road_angle(0.0)
    , distance(0.0)
    , turn_angle(0.0)  {
    }
  Yida_pose_(const ContainerAllocator& _alloc)
    : id(0)
    , x(0.0)
    , y(0.0)
    , z(0.0)
    , anglex(0.0)
    , angley(0.0)
    , anglez(0.0)
    , prob(0.0)
    , x1(0.0)
    , y1(0.0)
    , x2(0.0)
    , y2(0.0)
    , x3(0.0)
    , y3(0.0)
    , x4(0.0)
    , y4(0.0)
    , road_line_status(0)
    , robot_road_angle(0.0)
    , distance(0.0)
    , turn_angle(0.0)  {
  (void)_alloc;
    }



   typedef int32_t _id_type;
  _id_type id;

   typedef double _x_type;
  _x_type x;

   typedef double _y_type;
  _y_type y;

   typedef double _z_type;
  _z_type z;

   typedef float _anglex_type;
  _anglex_type anglex;

   typedef float _angley_type;
  _angley_type angley;

   typedef float _anglez_type;
  _anglez_type anglez;

   typedef float _prob_type;
  _prob_type prob;

   typedef float _x1_type;
  _x1_type x1;

   typedef float _y1_type;
  _y1_type y1;

   typedef float _x2_type;
  _x2_type x2;

   typedef float _y2_type;
  _y2_type y2;

   typedef float _x3_type;
  _x3_type x3;

   typedef float _y3_type;
  _y3_type y3;

   typedef float _x4_type;
  _x4_type x4;

   typedef float _y4_type;
  _y4_type y4;

   typedef int32_t _road_line_status_type;
  _road_line_status_type road_line_status;

   typedef float _robot_road_angle_type;
  _robot_road_angle_type robot_road_angle;

   typedef float _distance_type;
  _distance_type distance;

   typedef float _turn_angle_type;
  _turn_angle_type turn_angle;





  typedef boost::shared_ptr< ::yidamsg::Yida_pose_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::yidamsg::Yida_pose_<ContainerAllocator> const> ConstPtr;

}; // struct Yida_pose_

typedef ::yidamsg::Yida_pose_<std::allocator<void> > Yida_pose;

typedef boost::shared_ptr< ::yidamsg::Yida_pose > Yida_posePtr;
typedef boost::shared_ptr< ::yidamsg::Yida_pose const> Yida_poseConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::yidamsg::Yida_pose_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::yidamsg::Yida_pose_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace yidamsg

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsMessage': True, 'IsFixedSize': True, 'HasHeader': False}
// {'yidamsg': ['/home/mahxn0/catkin_ws/src/yidamsg/msg'], 'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'geometry_msgs': ['/opt/ros/kinetic/share/geometry_msgs/cmake/../msg'], 'sensor_msgs': ['/opt/ros/kinetic/share/sensor_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsMessage< ::yidamsg::Yida_pose_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::yidamsg::Yida_pose_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::yidamsg::Yida_pose_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::yidamsg::Yida_pose_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::yidamsg::Yida_pose_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::yidamsg::Yida_pose_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::yidamsg::Yida_pose_<ContainerAllocator> >
{
  static const char* value()
  {
    return "1952e558db386574a9633d011a903b3d";
  }

  static const char* value(const ::yidamsg::Yida_pose_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x1952e558db386574ULL;
  static const uint64_t static_value2 = 0xa9633d011a903b3dULL;
};

template<class ContainerAllocator>
struct DataType< ::yidamsg::Yida_pose_<ContainerAllocator> >
{
  static const char* value()
  {
    return "yidamsg/Yida_pose";
  }

  static const char* value(const ::yidamsg::Yida_pose_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::yidamsg::Yida_pose_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int32 id\n\
float64 x\n\
float64 y\n\
float64 z\n\
float32 anglex\n\
float32 angley\n\
float32 anglez\n\
float32 prob\n\
float32 x1\n\
float32 y1\n\
float32 x2\n\
float32 y2\n\
float32 x3\n\
float32 y3\n\
float32 x4\n\
float32 y4\n\
int32 road_line_status\n\
float32 robot_road_angle\n\
float32 distance\n\
float32 turn_angle\n\
\n\
";
  }

  static const char* value(const ::yidamsg::Yida_pose_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::yidamsg::Yida_pose_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.id);
      stream.next(m.x);
      stream.next(m.y);
      stream.next(m.z);
      stream.next(m.anglex);
      stream.next(m.angley);
      stream.next(m.anglez);
      stream.next(m.prob);
      stream.next(m.x1);
      stream.next(m.y1);
      stream.next(m.x2);
      stream.next(m.y2);
      stream.next(m.x3);
      stream.next(m.y3);
      stream.next(m.x4);
      stream.next(m.y4);
      stream.next(m.road_line_status);
      stream.next(m.robot_road_angle);
      stream.next(m.distance);
      stream.next(m.turn_angle);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Yida_pose_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::yidamsg::Yida_pose_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::yidamsg::Yida_pose_<ContainerAllocator>& v)
  {
    s << indent << "id: ";
    Printer<int32_t>::stream(s, indent + "  ", v.id);
    s << indent << "x: ";
    Printer<double>::stream(s, indent + "  ", v.x);
    s << indent << "y: ";
    Printer<double>::stream(s, indent + "  ", v.y);
    s << indent << "z: ";
    Printer<double>::stream(s, indent + "  ", v.z);
    s << indent << "anglex: ";
    Printer<float>::stream(s, indent + "  ", v.anglex);
    s << indent << "angley: ";
    Printer<float>::stream(s, indent + "  ", v.angley);
    s << indent << "anglez: ";
    Printer<float>::stream(s, indent + "  ", v.anglez);
    s << indent << "prob: ";
    Printer<float>::stream(s, indent + "  ", v.prob);
    s << indent << "x1: ";
    Printer<float>::stream(s, indent + "  ", v.x1);
    s << indent << "y1: ";
    Printer<float>::stream(s, indent + "  ", v.y1);
    s << indent << "x2: ";
    Printer<float>::stream(s, indent + "  ", v.x2);
    s << indent << "y2: ";
    Printer<float>::stream(s, indent + "  ", v.y2);
    s << indent << "x3: ";
    Printer<float>::stream(s, indent + "  ", v.x3);
    s << indent << "y3: ";
    Printer<float>::stream(s, indent + "  ", v.y3);
    s << indent << "x4: ";
    Printer<float>::stream(s, indent + "  ", v.x4);
    s << indent << "y4: ";
    Printer<float>::stream(s, indent + "  ", v.y4);
    s << indent << "road_line_status: ";
    Printer<int32_t>::stream(s, indent + "  ", v.road_line_status);
    s << indent << "robot_road_angle: ";
    Printer<float>::stream(s, indent + "  ", v.robot_road_angle);
    s << indent << "distance: ";
    Printer<float>::stream(s, indent + "  ", v.distance);
    s << indent << "turn_angle: ";
    Printer<float>::stream(s, indent + "  ", v.turn_angle);
  }
};

} // namespace message_operations
} // namespace ros

#endif // YIDAMSG_MESSAGE_YIDA_POSE_H
